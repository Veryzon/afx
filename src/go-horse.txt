Esta lista foi criada para ajudar a entender e/ou resolver problemas oriundos da qualidade do código.
Uma vez que tudo foi inicialmente prototipado com Go Horse, que é igual a forma errado só que mais rápida,
há uma caralhada de problemas.

// POSSÍVEIS PROBLEMAS

Uso de constante 4 ao invés de sizeof(type). Quando compilando em x64, tenha certeza que vai dar merda.

Quando realizando operações aritméticas sem parênteses envolvendo adição e multiplicação, o multiplicador é executado antes do adicionador, independente da ordem. Princípios de PEMDAS. Nós usamos parênteses extras para ajudar a noção.

Quando usando 'for', é possível que a variável de índice operada por 'for' não esteja sendo usada em favor do valor total.

Quando houver erros a respeito da alocação de memória em si, como corrupção anômala, é provável que haja transbordo em operações de cópia sem controle de tamanho, como população de strings esperando por um valor nulo.

Evite usar union's para converter valores. O compilador pode arranjar os dados com alinhamentos diferentes.

Quando usando afxArray's (mas pode ser qualquer alocação), tipos que se auto-referenciem, tais como afxString e afxLinkage, terão suas referêncais quebradas em caso de realocação onde o buffer mude de endereço.

Quando a afxChain começa por first linkage, avança-se com obtendo o prêvio linkage.

Usar array de float em lugar de array de double.

Processar empty string como zero-terminated string. Ignorar o tamanho e já partir para o ponteiro.

Loop dentro de loop usando a mesma variável de controle. Exemplo: i, j, etc.
warning : declaration shadows a local variable [-Wshadow]

Float sendo convertido para int e então para float. Principalmente fatores.

Ints sendo encapsulados em ints menores. Principalmente int array para structured int16/8.

Retornando referências para valores armazenados na call stack. Strucs, por exemplo.

Ao usar high-color (16-bit) video mode, Intel drivers doesn't provide WGL extensions, causing DPU creation failure.

Device-dependent classes sendo registradas com sizeof() básico devida a cópia da standard implementation.

Ponteiro sendo passado como pointero-ad-pointero.

Depth/stencil buffer não criado em operações com depth test.

0xC000001D: Illegal Instruction --- CPU doesn't support instructions such as AVX2.

0xC0000005: Access violation reading location 0x00000000 caused by SIMD-aligned variables will be a issue with the "memory block" not being allocated with SIMD alignment.

Wrong indexation counter inside array element accessor. Ex.: [idx++] // Increase before this access.

Allocated memory data corruption occurying after the first iteration may be caused by the *counter* missing the sizeof(type).

// POSSÍVEIS ABORDAGENS

NORM#1 O Qwadro não mais vai tentar evitar erros internos, apenas em entrada e saída de dados. O Qwadro apenas vai tentar informar argumentos inválidos. É responsabilidade do programador a resiliência e qualidade do código.

NORM#2 Quando uma operação é feita sob uma offset e um determinado range, deve usar tais termos. Se for operações de cópia correlativas, prefira os termos Input/Output para copy into e copy out.

NORM#3 Quando uma operação é feita sob uma source com parâmetros de precisão, tais como offset, range e stride, tais parâmetros devem ser posicionados após o parâmetro de alimentação para clareza.

Draw system poderia arranjar implementation-dependent draw contexts e dispô-los para os draw context agnósticos.

Eventos de objetos-filho deveriam ser enviados ao parente apenas.

Criar um objeto 'afxHandle*' segurando um ponteiro para um afxHandle. Referências poderiam ser movidas para o afxHandle*, talvez.
O afxHandle* seria um conector de afxHandle's tal como um binding. Venceria uma limitação de afxLinkage.

// CONVENÇÃO DE NOMENCLATURAS

Clone -> Quando um novo objeto com igual conteúdo é criado.
Copy -> Quando apenas o conteúdo é copiado entre dois objetos já existentes.
Input/Output -> Quando apenas o conteúdo é copiados com "parâmetros não-garantidos" pelo Qwadro. A exemplo, passando 'offset' e/ou 'range' especificados pelo invocador.
Fetch -> Quando há 'destreza' em uma função para conseguir algo. A exemplo, carregando um arquivo implicitamente.
Deploy -> Quando um objeto não-referenciável é empregado, isto é, inicializado, mas não é alocado.
Drop -> Quando um objeto não-referenciável é retirado, isto é, zerado, mas não é desalocado.

Funções Enumerate() deveriam contar quantas instâncias há caso um receptáculo não seja passado adentro.

// TODO

Carregar arquivos ZIP como diretórios virtuais.
Carregar objetos por JSON.

