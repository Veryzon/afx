<Qwadro>
    <Shader stage='VERTEX' name='vsRigid'>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Include>data/pipeline/stdView.inc</Include>
        <Include>data/pipeline/stdObject.inc</Include>
        <Resource type='CONSTANT_BUFFER'>sgl_view</Resource>
        <Resource set='3' type='CONSTANT_BUFFER'>sgl_obj</Resource>
        <In location='0' format='V4D'>aPos</In>
        <In location='1' format='V3D'>aNormal</In>
        <In location='2' format='V2D'>aUv</In>
        <![CDATA[
        
        layout (location = 0) in vec4 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aUv;

        const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 0.2);
        
        out block
        {
            vec3 Position;
            vec4 Diffuse;
            vec2 Tex0;
        } sgl_v;

        void main()
        {
            vec3 ObjNormal = vec3(v * inverse(m) * vec4(aNormal, 0));

            gl_Position = p * v * m * aPos;
            sgl_v.Tex0     = aUv;
            sgl_v.Diffuse  = starKd * (dot(ObjNormal, starDir)) + AmbientColour;
        }
        ]]>
    </Shader>
    <Shader stage='VERTEX' name='vsSkinned'>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Include>data/pipeline/stdView.inc</Include>
        <Include>data/pipeline/stdObject.inc</Include>
        <Resource type='CONSTANT_BUFFER'>sgl_view</Resource>
        <Resource set='3' type='CONSTANT_BUFFER'>sgl_obj</Resource>
        <In location='0' format='V3D'>aPos</In>
        <In location='1' format='V3D'>aNormal</In>
        <In location='2' format='V2D'>aUv</In>
        <In location='3' format='V4D'>aBlendIndices</In>
        <In location='4' format='V4D'>aBlendWeights</In>
        <![CDATA[
        
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aUv;
        layout (location = 3) in vec4 aBlendIndices;
        layout (location = 4) in vec4 aBlendWeights;

        out block
        {
            vec3 Position;
            vec4 Diffuse;
            vec2 Tex0;
        } sgl_v;

        const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 0.2);
        
        void main()
        {
            vec4 InPos     = vec4( aPos, 1 );
            vec4 WorldPos    = 0;
            vec3 WorldNormal = 0;
            
            // We're going to assume that we can transform the normal by the matrix, which is not
            // technically correct unless we're positive there's not a scaling factor involved.

            for( int i = 0; i < 4; ++i )
            {
                mat4 BoneMatrix = m[int(aBlendIndices[i])];
                WorldPos    += (aBlendWeights[i] * vec4( InPos * BoneMatrix ));
                WorldNormal += vec3(vec4(aBlendWeights[i] * vec4( vec4( aNormal, 0 ) * BoneMatrix )));
            }

            vec4 ViewPosL = (WorldPos * v);
            vec4 ClipPos = (ViewPosL * p);
            gl_Position = ClipPos;
            sgl_v.Position   = vec3(ClipPos);
            sgl_v.Tex0    = aUv;
            sgl_v.Diffuse = starKd * (dot(normalize(WorldNormal), starDir)) + AmbientColour;
        }
        ]]>
    </Shader>
    <Shader stage='FRAGMENT' name='fs'>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Resource set='2' type='COMBINED_IMAGE_SAMPLER'>diffuse_sampler</Resource>
        <Out format='V4D'>FragColor</Out>
        <![CDATA[
        
        uniform sampler2D diffuse_sampler;
        
        in block
        {
            vec3 Position;
            vec4 Diffuse;
            vec2 Tex0;
        } sgl_v;
        
        out vec4 FragColor;
        
        void main()
        {
            FragColor = /*texture( diffuse_sampler, sgl_v.Tex0 ) * */sgl_v.Diffuse;
        }
        ]]>
    </Shader>
    <DrawOperation>
        <Technique name='rigid'>
            <Pass>
                <FillMode>SOLID</FillMode>
                <CullMode>BACK</CullMode>
                <FrontFace>CCW</FrontFace>
                <DepthTestEnable>true</DepthTestEnable>
                <DepthWriteEnable>true</DepthWriteEnable>
                <DepthCompareOp>LESS</DepthCompareOp>
                <Input topology='TRI_LIST' />
                <Shader stage='VERTEX'>data/pipeline/body.xml?vsRigid</Shader>
                <Shader stage='FRAGMENT'>data/pipeline/body.xml?fs</Shader>
            </Pass>
        </Technique>
        <Technique name='skinned'>
            <Pass>
                <FillMode>SOLID</FillMode>
                <CullMode>BACK</CullMode>
                <FrontFace>CCW</FrontFace>
                <DepthTestEnable>true</DepthTestEnable>
                <DepthWriteEnable>true</DepthWriteEnable>
                <DepthCompareOp>LESS</DepthCompareOp>
                <Input topology='TRI_LIST' />
                <Shader stage='VERTEX'>data/pipeline/body.xml?vsSkinned</Shader>
                <Shader stage='FRAGMENT'>data/pipeline/body.xml?fs</Shader>
            </Pass>
        </Technique>
    </DrawOperation>
</Qwadro>
