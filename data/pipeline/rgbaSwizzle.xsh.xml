<Qwadro>
    <Shader id='quadVs'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 tristrippedQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 tristrippedQuadUv[4] = vec2[](vec2(0, 1), vec2(0, 0), vec2(1, 1), vec2(1, 0));

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw tristrip with 4 tri indices.
            gl_Position = tristrippedQuadPos[gl_VertexID];
            sgl_v.uv0 = tristrippedQuadUv[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='quadFlippedVertVs'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[
        
        const vec4 tristrippedQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 tristrippedQuadUvFlippedY[4] = vec2[](vec2(0, 0), vec2(0, 1), vec2(1, 0), vec2(1, 1));
        // flipped V only
        
        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw tristrip with 4 tri indices.
            gl_Position = tristrippedQuadPos[gl_VertexID];
            sgl_v.uv0 = tristrippedQuadUvFlippedY[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='quadFlippedHoriVs'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[
        
        const vec4 tristrippedQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 tristrippedQuadUvFlippedX[4] = vec2[](vec2(1, 1), vec2(1, 0), vec2(0, 1), vec2(0, 0));
        // flipped U only

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw tristrip with 4 tri indices.
            gl_Position = tristrippedQuadPos[gl_VertexID];
            sgl_v.uv0 = tristrippedQuadUvFlippedX[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='quadFlippedUvVs'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 tristrippedQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 tristrippedQuadUvFlippedXy[4] = vec2[](vec2(1, 0), vec2(1, 1), vec2(0, 0), vec2(0, 1));
        // flipped UV

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw tristrip with 4 tri indices.
            gl_Position = tristrippedQuadPos[gl_VertexID];
            sgl_v.uv0 = tristrippedQuadUvFlippedXy[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='fs'>
        <Stage>FRAGMENT</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Resource type='COMBINED_IMAGE_SAMPLER'>samp</Resource>
        <Out>vec4 sgl_rgba</Out>
        <![CDATA[
        
        uniform sampler2D samp;

        in block
        {
            vec2 uv0;
        } sgl_v;

        out vec4 sgl_rgba;

        void main()
        {
            sgl_rgba = texture(samp, sgl_v.uv0);
        }
        ]]>
    </Shader>
    <Pipeline>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_STRIP</PrimitiveTopology>
        <VertexShader>data/pipeline/rgbaToRgba.xsh.xml?tristrippedQuadVs</VertexShader>
        <Rasterizer>data/pipeline/rgbaToRgba.xsh.xml</Rasterizer>
    </Pipeline>
    <Pipeline id='yFlipped'>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_STRIP</PrimitiveTopology>
        <VertexShader>data/pipeline/rgbaToRgba.xsh.xml?tristrippedQuadUvFlippedVs</VertexShader>
        <Rasterizer>data/pipeline/rgbaToRgba.xsh.xml</Rasterizer>
    </Pipeline>
    <Rasterizer>
        <FillMode>SOLID</FillMode>
        <DepthWriteEnabled></DepthWriteEnabled>
        <FragmentShader>data/pipeline/rgbaToRgba.xsh.xml?fs</FragmentShader>
    </Rasterizer>
</Qwadro>
