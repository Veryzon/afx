<Qwadro>
    <Shader id='vsTri'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 gsTriPos[3] = vec4[](vec4(-1, -1, 0, 1), vec4(3,-1, 0, 1), vec4(-1, 3, 0, 1));
        const vec2 gsTriUv[3] = vec2[](vec2(0, 0), vec2(2, 0), vec2(0, 2));

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage triangle (3 indices).
            gl_Position = gsTriPos[gl_VertexID];
            sgl_v.uv0 = gsTriUv[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='vsTriXform'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 gsTriPos[3] = vec4[](vec4(-1, -1, 0, 1), vec4(3,-1, 0, 1), vec4(-1, 3, 0, 1));
        const vec2 gsTriUv[3] = vec2[](vec2(0, 0), vec2(2, 0), vec2(0, 2));

        uniform mat4 m;
        
        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage triangle (3 indices).
            gl_Position = gsTriPos[gl_VertexID];
            sgl_v.uv0 = vec2(m * vec4(gsTriUv[gl_VertexID]));
        }
        ]]>
    </Shader>
    <Shader id='vsQuad'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 gsQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 gsQuadUv[4] = vec2[](vec2(0, 1), vec2(0, 0), vec2(1, 1), vec2(1, 0));

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage quad using two tristripped triangles (4 indices).
            gl_Position = gsQuadPos[gl_VertexID];
            sgl_v.uv0 = gsQuadUv[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='vsQuadFlippedU'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[
        
        const vec4 gsQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 gsQuadUvFlippedX[4] = vec2[](vec2(1, 1), vec2(1, 0), vec2(0, 1), vec2(0, 0));
        // flipped U only

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage quad using two tristripped triangles (4 indices).
            gl_Position = gsQuadPos[gl_VertexID];
            sgl_v.uv0 = gsQuadUvFlippedX[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='vsQuadFlippedV'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[
        
        const vec4 gsQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 gsQuadUvFlippedY[4] = vec2[](vec2(0, 0), vec2(0, 1), vec2(1, 0), vec2(1, 1));
        // flipped V only
        
        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage quad using two tristripped triangles (4 indices).
            gl_Position = gsQuadPos[gl_VertexID];
            sgl_v.uv0 = gsQuadUvFlippedY[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='vsQuadFlippedUv'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <![CDATA[

        const vec4 gsQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
        const vec2 gsQuadUvFlippedXy[4] = vec2[](vec2(1, 0), vec2(1, 1), vec2(0, 0), vec2(0, 1));
        // flipped UV

        out block
        {
            vec2 uv0;
        } sgl_v;

        void main()
        {
            // draw a full coverage quad using two tristripped triangles (4 indices).
            gl_Position = gsQuadPos[gl_VertexID];
            sgl_v.uv0 = gsQuadUvFlippedXy[gl_VertexID];
        }
        ]]>
    </Shader>
    <Shader id='fsBlit'>
        <Stage>FRAGMENT</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Resource type='COMBINED_IMAGE_SAMPLER'>samp</Resource>
        <Out>vec4 sgl_rgba</Out>
        <![CDATA[
        
        uniform sampler2D samp;

        in block
        {
            vec2 uv0;
        } sgl_v;

        out vec4 sgl_rgba;

        void main()
        {
            sgl_rgba = texture(samp, sgl_v.uv0);
        }
        ]]>
    </Shader>
    <Pipeline>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_STRIP</PrimitiveTopology>
        <VertexShader>data/pipeline/rgbaToRgba.xsh.xml?tristrippedQuadVs</VertexShader>
        <Rasterizer>data/pipeline/rgbaToRgba.xsh.xml</Rasterizer>
    </Pipeline>
    <Pipeline id='yFlipped'>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_STRIP</PrimitiveTopology>
        <VertexShader>data/pipeline/rgbaToRgba.xsh.xml?tristrippedQuadUvFlippedVs</VertexShader>
        <Rasterizer>data/pipeline/rgbaToRgba.xsh.xml</Rasterizer>
    </Pipeline>
    <Rasterizer>
        <FillMode>SOLID</FillMode>
        <DepthWriteEnabled></DepthWriteEnabled>
        <FragmentShader>data/pipeline/rgbaToRgba.xsh.xml?fs</FragmentShader>
    </Rasterizer>
</Qwadro>
