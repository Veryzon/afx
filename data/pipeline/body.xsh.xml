<Qwadro>
    <Shader id='vsRigid'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Include>data/pipeline/stdView.inc</Include>
        <Include>data/pipeline/stdObject.inc</Include>
        <Resource type='CONSTANT_BUFFER'>sgl_view</Resource>
        <Resource set='3' type='CONSTANT_BUFFER'>sgl_obj</Resource>
        <In location='0' format='V4D' stream='0'>aPos</In>
        <In location='3' format='V3D' stream='1'>aNormal</In>
        <In location='6' format='V2D' stream='1'>aUv</In>
        <![CDATA[
        
        layout (location = 0) in vec4 aPos;
        layout (location = 3) in vec3 aNormal;
        layout (location = 6) in vec2 aUv;

        const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 1.0);
        
        out block
        {
            vec3 xyz;
            vec3 nrm;
            vec2 uv0;
        } sgl_v;

        void main()
        {
            sgl_v.xyz = vec3(m * aPos);
            sgl_v.nrm = mat3(transpose(inverse(m))) * aNormal;  
            
            gl_Position = p * v * vec4(sgl_v.xyz, 1.0);
        }
        ]]>
    </Shader>
    <Shader id='vsSkinned'>
        <Stage>VERTEX</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Include>data/pipeline/stdView.inc</Include>
        <Include>data/pipeline/stdObject.inc</Include>
        <Resource type='CONSTANT_BUFFER'>sgl_view</Resource>
        <Resource set='3' type='CONSTANT_BUFFER'>sgl_obj</Resource>
        <In location='0' format='V4D' stream='0'>aPos</In>
        <In location='3' format='V3D' stream='1'>aNormal</In>
        <In location='6' format='V2D' stream='1'>aUv</In>
        <In location='1' format='V4D' stream='0'>aBlendIndices</In>
        <In location='2' format='V4D' stream='0'>aBlendWeights</In>
        <![CDATA[
        
        layout (location = 0) in vec4 aPos;
        layout (location = 3) in vec3 aNormal;
        layout (location = 5) in vec2 aUv;
        layout (location = 1) in vec4 aBlendIndices;
        layout (location = 2) in vec4 aBlendWeights;

        out block
        {
            vec3 Position;
            vec4 Diffuse;
            vec2 Tex0;
        } sgl_v;

        const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 1.0);
        
        void main()
        {
            vec4 InPos     = aPos;
            vec4 WorldPos    = 0;
            vec3 WorldNormal = 0;
            
            // We're going to assume that we can transform the normal by the matrix, which is not
            // technically correct unless we're positive there's not a scaling factor involved.

            for( int i = 0; i < 4; ++i )
            {
                mat4 BoneMatrix = w[int(aBlendIndices[i])];
                WorldPos    += (aBlendWeights[i] * vec4( InPos * BoneMatrix ));
                WorldNormal += vec3(vec4(aBlendWeights[i] * vec4( vec4( aNormal, 0 ) * BoneMatrix )));
            }

            vec4 ViewPosL = (WorldPos * v);
            vec4 ClipPos = (ViewPosL * p);
            gl_Position = ClipPos;
            sgl_v.Position   = vec3(ClipPos);
            sgl_v.Tex0    = aUv;
            sgl_v.Diffuse = starKd * (dot(normalize(WorldNormal), starDir)) + AmbientColour;
        }
        ]]>
    </Shader>
    <Shader id='fs'>
        <Stage>FRAGMENT</Stage>
        <Include>data/pipeline/stdEnv.inc</Include>
        <Include>data/pipeline/stdView.inc</Include>
        <Include>data/pipeline/stdMaterial.inc</Include>
        <Resource type='CONSTANT_BUFFER'>sgl_view</Resource>
        <Resource set='2' type='CONSTANT_BUFFER'>sgl_mtl</Resource>
        <Resource set='2' binding='1' type='COMBINED_IMAGE_SAMPLER'>diffuse_sampler</Resource>
        <Out location='0' format='V4D'>FragColor</Out>
        <![CDATA[
        
        uniform sampler2D diffuse_sampler;
        
        in block
        {
            vec3 xyz;
            vec3 nrm;
            vec2 uv0;
        } sgl_v;
        
        out vec4 FragColor;
        
        const vec3 lightPosition = vec3(10, 10, 10);
        const vec3 lightAmbient = vec3(0.1, 0.1, 0.1);
        const vec3 lightDiffuse = vec3(0.5, 0.5, 0.5);
        const vec3 lightSpecular = vec3(0.5, 0.5, 0.5);
        
        void main()
        {
            // ambient
            vec3 ambient = lightAmbient;
            
            // diffuse 
            vec3 norm = normalize(sgl_v.nrm);
            vec3 lightDir = normalize(lightPosition - sgl_v.xyz);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = lightDiffuse * (diff * Kd);
            
            // specular
            vec3 viewDir = normalize(vec3(viewpoint.xyz) - sgl_v.xyz);
            vec3 reflectDir = reflect(-lightDir, norm);  
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), Ns);
            vec3 specular = lightSpecular * (spec * Ks);  
                
            vec3 result = ambient + diffuse + specular;
            FragColor = vec4(result, 1.0);
        }
        ]]>
    </Shader>
    <Pipeline id='rigid'>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_LIST</PrimitiveTopology>
        <Shader>data/pipeline/body.xsh.xml?vsRigid</Shader>
        <Shader>data/pipeline/body.xsh.xml?fs</Shader>
        <Rasterizer>data/pipeline/body.xsh.xml</Rasterizer>
    </Pipeline>
    <Pipeline id='skinned'>
        <CullMode>BACK</CullMode>
        <PrimitiveTopology>TRI_LIST</PrimitiveTopology>
        <Shader specialization='1'>data/pipeline/body.xsh.xml?vsSkinned</Shader>
        <Shader>data/pipeline/body.xsh.xml?fs</Shader>
        <Rasterizer>data/pipeline/body.xsh.xml</Rasterizer>
    </Pipeline>
    <Rasterizer>
        <DepthTestEnabled></DepthTestEnabled>
        <DepthWriteEnabled></DepthWriteEnabled>
        <FillMode>SOLID</FillMode>
        <DepthCompareOp>LESS</DepthCompareOp>
    </Rasterizer>
</Qwadro>
