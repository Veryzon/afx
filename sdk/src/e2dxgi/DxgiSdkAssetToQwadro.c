/*
 *          ::::::::  :::       :::     :::     :::::::::  :::::::::   ::::::::
 *         :+:    :+: :+:       :+:   :+: :+:   :+:    :+: :+:    :+: :+:    :+:
 *         +:+    +:+ +:+       +:+  +:+   +:+  +:+    +:+ +:+    +:+ +:+    +:+
 *         +#+    +:+ +#+  +:+  +#+ +#++:++#++: +#+    +:+ +#++:++#:  +#+    +:+
 *         +#+  # +#+ +#+ +#+#+ +#+ +#+     +#+ +#+    +#+ +#+    +#+ +#+    +#+
 *         #+#   +#+   #+#+# #+#+#  #+#     #+# #+#    #+# #+#    #+# #+#    #+#
 *          ###### ###  ###   ###   ###     ### #########  ###    ###  ########
 *
 *                  Q W A D R O   E X E C U T I O N   E C O S Y S T E M
 *
 *                                   Public Test Build
 *                       (c) 2017 SIGMA, Engineering In Technology
 *                             <https://sigmaco.org/qwadro/>
 */

#include "qwadro/sim/afxSimulation.h"

#define MAX_PATH 260 // windows

// .SDKMESH files

// SDKMESH_HEADER
// SDKMESH_VERTEX_BUFFER_HEADER header->VertexStreamHeadersOffset
// SDKMESH_INDEX_BUFFER_HEADER  header->IndexStreamHeadersOffset
// SDKMESH_MESH                 header->MeshDataOffset
// SDKMESH_SUBSET               header->SubsetDataOffset
// SDKMESH_FRAME                header->FrameDataOffset
// SDKMESH_MATERIAL             header->MaterialDataOffset
// [header->NonBufferDataSize]
// { [ header->NumVertexBuffers]
//      VB data
// }
// { [ header->NumIndexBuffers]
//      IB data
// }


// .SDDKANIM files

// SDKANIMATION_FILE_HEADER
// uint8_t[] - Length of fileheader->AnimationDataSize

// .SDKMESH uses Direct3D 9 decls, but only a subset of these is ever generated by the legacy DirectX SDK Content Exporter

// D3DDECLUSAGE_POSITION / D3DDECLTYPE_FLOAT3
// (D3DDECLUSAGE_BLENDWEIGHT / D3DDECLTYPE_UBYTE4N
// D3DDECLUSAGE_BLENDINDICES / D3DDECLTYPE_UBYTE4)?
// (D3DDECLUSAGE_NORMAL / D3DDECLTYPE_FLOAT3, D3DDECLTYPE_FLOAT16_4, D3DDECLTYPE_SHORT4N, D3DDECLTYPE_UBYTE4N, or D3DDECLTYPE_DEC3N)?
// (D3DDECLUSAGE_COLOR / D3DDECLTYPE_D3DCOLOR)?
// (D3DDECLUSAGE_TEXCOORD / D3DDECLTYPE_FLOAT1, D3DDECLTYPE_FLOAT2 or D3DDECLTYPE_FLOAT16_2, D3DDECLTYPE_FLOAT3 or D3DDECLTYPE_FLOAT16_4, D3DDECLTYPE_FLOAT4 or D3DDECLTYPE_FLOAT16_4)*
// (D3DDECLUSAGE_TANGENT / same as D3DDECLUSAGE_NORMAL)?
// (D3DDECLUSAGE_BINORMAL / same as D3DDECLUSAGE_NORMAL)?

typedef enum D3DDECLUSAGE
{
    D3DDECLUSAGE_POSITION = 0,
    D3DDECLUSAGE_BLENDWEIGHT = 1,
    D3DDECLUSAGE_BLENDINDICES = 2,
    D3DDECLUSAGE_NORMAL = 3,
    D3DDECLUSAGE_TEXCOORD = 5,
    D3DDECLUSAGE_TANGENT = 6,
    D3DDECLUSAGE_BINORMAL = 7,
    D3DDECLUSAGE_COLOR = 10,
} D3DDECLUSAGE;

typedef enum DXGI_FORMAT
{
    DXGI_FORMAT_UNKNOWN = 0,
    DXGI_FORMAT_R32G32B32A32_TYPELESS = 1,
    DXGI_FORMAT_R32G32B32A32_FLOAT = 2,
    DXGI_FORMAT_R32G32B32A32_UINT = 3,
    DXGI_FORMAT_R32G32B32A32_SINT = 4,
    DXGI_FORMAT_R32G32B32_TYPELESS = 5,
    DXGI_FORMAT_R32G32B32_FLOAT = 6,
    DXGI_FORMAT_R32G32B32_UINT = 7,
    DXGI_FORMAT_R32G32B32_SINT = 8,
    DXGI_FORMAT_R16G16B16A16_TYPELESS = 9,
    DXGI_FORMAT_R16G16B16A16_FLOAT = 10,
    DXGI_FORMAT_R16G16B16A16_UNORM = 11,
    DXGI_FORMAT_R16G16B16A16_UINT = 12,
    DXGI_FORMAT_R16G16B16A16_SNORM = 13,
    DXGI_FORMAT_R16G16B16A16_SINT = 14,
    DXGI_FORMAT_R32G32_TYPELESS = 15,
    DXGI_FORMAT_R32G32_FLOAT = 16,
    DXGI_FORMAT_R32G32_UINT = 17,
    DXGI_FORMAT_R32G32_SINT = 18,
    DXGI_FORMAT_R32G8X24_TYPELESS = 19,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21,
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22,
    DXGI_FORMAT_R10G10B10A2_TYPELESS = 23,
    DXGI_FORMAT_R10G10B10A2_UNORM = 24,
    DXGI_FORMAT_R10G10B10A2_UINT = 25,
    DXGI_FORMAT_R11G11B10_FLOAT = 26,
    DXGI_FORMAT_R8G8B8A8_TYPELESS = 27,
    DXGI_FORMAT_R8G8B8A8_UNORM = 28,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29,
    DXGI_FORMAT_R8G8B8A8_UINT = 30,
    DXGI_FORMAT_R8G8B8A8_SNORM = 31,
    DXGI_FORMAT_R8G8B8A8_SINT = 32,
    DXGI_FORMAT_R16G16_TYPELESS = 33,
    DXGI_FORMAT_R16G16_FLOAT = 34,
    DXGI_FORMAT_R16G16_UNORM = 35,
    DXGI_FORMAT_R16G16_UINT = 36,
    DXGI_FORMAT_R16G16_SNORM = 37,
    DXGI_FORMAT_R16G16_SINT = 38,
    DXGI_FORMAT_R32_TYPELESS = 39,
    DXGI_FORMAT_D32_FLOAT = 40,
    DXGI_FORMAT_R32_FLOAT = 41,
    DXGI_FORMAT_R32_UINT = 42,
    DXGI_FORMAT_R32_SINT = 43,
    DXGI_FORMAT_R24G8_TYPELESS = 44,
    DXGI_FORMAT_D24_UNORM_S8_UINT = 45,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46,
    DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47,
    DXGI_FORMAT_R8G8_TYPELESS = 48,
    DXGI_FORMAT_R8G8_UNORM = 49,
    DXGI_FORMAT_R8G8_UINT = 50,
    DXGI_FORMAT_R8G8_SNORM = 51,
    DXGI_FORMAT_R8G8_SINT = 52,
    DXGI_FORMAT_R16_TYPELESS = 53,
    DXGI_FORMAT_R16_FLOAT = 54,
    DXGI_FORMAT_D16_UNORM = 55,
    DXGI_FORMAT_R16_UNORM = 56,
    DXGI_FORMAT_R16_UINT = 57,
    DXGI_FORMAT_R16_SNORM = 58,
    DXGI_FORMAT_R16_SINT = 59,
    DXGI_FORMAT_R8_TYPELESS = 60,
    DXGI_FORMAT_R8_UNORM = 61,
    DXGI_FORMAT_R8_UINT = 62,
    DXGI_FORMAT_R8_SNORM = 63,
    DXGI_FORMAT_R8_SINT = 64,
    DXGI_FORMAT_A8_UNORM = 65,
    DXGI_FORMAT_R1_UNORM = 66,
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67,
    DXGI_FORMAT_R8G8_B8G8_UNORM = 68,
    DXGI_FORMAT_G8R8_G8B8_UNORM = 69,
    DXGI_FORMAT_BC1_TYPELESS = 70,
    DXGI_FORMAT_BC1_UNORM = 71,
    DXGI_FORMAT_BC1_UNORM_SRGB = 72,
    DXGI_FORMAT_BC2_TYPELESS = 73,
    DXGI_FORMAT_BC2_UNORM = 74,
    DXGI_FORMAT_BC2_UNORM_SRGB = 75,
    DXGI_FORMAT_BC3_TYPELESS = 76,
    DXGI_FORMAT_BC3_UNORM = 77,
    DXGI_FORMAT_BC3_UNORM_SRGB = 78,
    DXGI_FORMAT_BC4_TYPELESS = 79,
    DXGI_FORMAT_BC4_UNORM = 80,
    DXGI_FORMAT_BC4_SNORM = 81,
    DXGI_FORMAT_BC5_TYPELESS = 82,
    DXGI_FORMAT_BC5_UNORM = 83,
    DXGI_FORMAT_BC5_SNORM = 84,
    DXGI_FORMAT_B5G6R5_UNORM = 85,
    DXGI_FORMAT_B5G5R5A1_UNORM = 86,
    DXGI_FORMAT_B8G8R8A8_UNORM = 87,
    DXGI_FORMAT_B8G8R8X8_UNORM = 88,
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89,
    DXGI_FORMAT_B8G8R8A8_TYPELESS = 90,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91,
    DXGI_FORMAT_B8G8R8X8_TYPELESS = 92,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93,
    DXGI_FORMAT_BC6H_TYPELESS = 94,
    DXGI_FORMAT_BC6H_UF16 = 95,
    DXGI_FORMAT_BC6H_SF16 = 96,
    DXGI_FORMAT_BC7_TYPELESS = 97,
    DXGI_FORMAT_BC7_UNORM = 98,
    DXGI_FORMAT_BC7_UNORM_SRGB = 99,
    DXGI_FORMAT_AYUV = 100,
    DXGI_FORMAT_Y410 = 101,
    DXGI_FORMAT_Y416 = 102,
    DXGI_FORMAT_NV12 = 103,
    DXGI_FORMAT_P010 = 104,
    DXGI_FORMAT_P016 = 105,
    DXGI_FORMAT_420_OPAQUE = 106,
    DXGI_FORMAT_YUY2 = 107,
    DXGI_FORMAT_Y210 = 108,
    DXGI_FORMAT_Y216 = 109,
    DXGI_FORMAT_NV11 = 110,
    DXGI_FORMAT_AI44 = 111,
    DXGI_FORMAT_IA44 = 112,
    DXGI_FORMAT_P8 = 113,
    DXGI_FORMAT_A8P8 = 114,
    DXGI_FORMAT_B4G4R4A4_UNORM = 115,
    DXGI_FORMAT_P208 = 130,
    DXGI_FORMAT_V208 = 131,
    DXGI_FORMAT_V408 = 132,
    DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE,
    DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE,
    DXGI_FORMAT_FORCE_UINT = 0xffffffff
} DXGI_FORMAT;

typedef enum D3DDECLTYPE
{
    D3DDECLTYPE_FLOAT1 = 0,  // 1D float expanded to (value, 0., 0., 1.)
    D3DDECLTYPE_FLOAT2 = 1,  // 2D float expanded to (value, value, 0., 1.)
    D3DDECLTYPE_FLOAT3 = 2,  // 3D float expanded to (value, value, value, 1.)
    D3DDECLTYPE_FLOAT4 = 3,  // 4D float
    D3DDECLTYPE_D3DCOLOR = 4,  // 4D packed unsigned bytes mapped to 0. to 1. range
    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
    D3DDECLTYPE_UBYTE4 = 5,  // 4D unsigned uint8_t
    D3DDECLTYPE_UBYTE4N = 8,  // Each of 4 bytes is normalized by dividing to 255.0
    D3DDECLTYPE_SHORT4N = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
    D3DDECLTYPE_DEC3N = 14,  // 3D signed normalized (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1.)
    // Note: There is no equivalent to D3DDECLTYPE_DEC3N (14) as a DXGI_FORMAT
    D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
    D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values

    D3DDECLTYPE_UNUSED = 17,  // When the type field in a decl is unused.

    // These are extensions for DXGI-based versions of Direct3D
    D3DDECLTYPE_DXGI_R10G10B10A2_UNORM = 32 + DXGI_FORMAT_R10G10B10A2_UNORM,
    D3DDECLTYPE_DXGI_R11G11B10_FLOAT = 32 + DXGI_FORMAT_R11G11B10_FLOAT,
    D3DDECLTYPE_DXGI_R8G8B8A8_SNORM = 32 + DXGI_FORMAT_R8G8B8A8_SNORM,
}D3DDECLTYPE;

#pragma pack(push,4)

AFX_DEFINE_STRUCT(D3DVERTEXELEMENT9)
{
    afxNat16 Stream;     // Stream index
    afxNat16 Offset;     // Offset in the stream in bytes
    afxNat8  Type;       // Data type
    afxNat8  Method;     // Processing method
    afxNat8  Usage;      // Semantics
    afxNat8  UsageIndex; // Semantic index
};

#pragma pack(pop)

//--------------------------------------------------------------------------------------
// Hard Defines for the various structures
//--------------------------------------------------------------------------------------

#define SDKMESH_FILE_VERSION 101
#define SDKMESH_FILE_VERSION_V2 200

#define MAX_VERTEX_ELEMENTS 32
#define MAX_VERTEX_STREAMS 16
#define MAX_FRAME_NAME 100
#define MAX_MESH_NAME 100
#define MAX_SUBSET_NAME 100
#define MAX_MATERIAL_NAME 100
#define MAX_TEXTURE_NAME MAX_PATH
#define MAX_MATERIAL_PATH MAX_PATH
#define INVALID_FRAME (afxNat32)-1
#define INVALID_MESH (afxNat32)-1
#define INVALID_MATERIAL (afxNat32)-1
#define INVALID_SUBSET (afxNat32)-1
#define INVALID_ANIMATION_DATA (afxNat32)-1

//--------------------------------------------------------------------------------------
// Enumerated Types.
//--------------------------------------------------------------------------------------
typedef enum SDKMESH_PRIMITIVE_TYPE
{
    PT_TRIANGLE_LIST = 0,
    PT_TRIANGLE_STRIP,
    PT_LINE_LIST,
    PT_LINE_STRIP,
    PT_POINT_LIST,
    PT_TRIANGLE_LIST_ADJ,
    PT_TRIANGLE_STRIP_ADJ,
    PT_LINE_LIST_ADJ,
    PT_LINE_STRIP_ADJ,
    PT_QUAD_PATCH_LIST,
    PT_TRIANGLE_PATCH_LIST,
}SDKMESH_PRIMITIVE_TYPE;

typedef enum SDKMESH_INDEX_TYPE
{
    IT_16BIT = 0,
    IT_32BIT,
}SDKMESH_INDEX_TYPE;

typedef enum FRAME_TRANSFORM_TYPE
{
    FTT_RELATIVE = 0,
    FTT_ABSOLUTE, // This is not currently used but is here to support absolute transformations in the future
}FRAME_TRANSFORM_TYPE;

//--------------------------------------------------------------------------------------
// Structures.
//--------------------------------------------------------------------------------------
#pragma pack(push,8)

AFX_DEFINE_STRUCT(SDKMESH_HEADER)
{
    //Basic Info and sizes
    afxNat32 Version;
    afxNat8  IsBigEndian;
    afxNat64 HeaderSize;
    afxNat64 NonBufferDataSize;
    afxNat64 BufferDataSize;

    //Stats
    afxNat32 NumVertexBuffers;
    afxNat32 NumIndexBuffers;
    afxNat32 NumMeshes;
    afxNat32 NumTotalSubsets;
    afxNat32 NumFrames;
    afxNat32 NumMaterials;

    //Offsets to Data
    afxNat64 VertexStreamHeadersOffset;
    afxNat64 IndexStreamHeadersOffset;
    afxNat64 MeshDataOffset;
    afxNat64 SubsetDataOffset;
    afxNat64 FrameDataOffset;
    afxNat64 MaterialDataOffset;
};

AFX_DEFINE_STRUCT(SDKMESH_VERTEX_BUFFER_HEADER)
{
    afxNat64 NumVertices;
    afxNat64 SizeBytes;
    afxNat64 StrideBytes;
    D3DVERTEXELEMENT9 Decl[MAX_VERTEX_ELEMENTS];
    afxNat64 DataOffset;
};

AFX_DEFINE_STRUCT(SDKMESH_INDEX_BUFFER_HEADER)
{
    afxNat64 NumIndices;
    afxNat64 SizeBytes;
    afxNat32 IndexType;
    afxNat64 DataOffset;
};

AFX_DEFINE_STRUCT(SDKMESH_MESH)
{
    afxChar Name[MAX_MESH_NAME];
    afxNat8 NumVertexBuffers;
    afxNat32 VertexBuffers[MAX_VERTEX_STREAMS];
    afxNat32 IndexBuffer;
    afxNat32 NumSubsets;
    afxNat32 NumFrameInfluences; //aka bones

    afxV3d BoundingBoxCenter;
    afxV3d BoundingBoxExtents;

    union
    {
        afxNat64 SubsetOffset;
        afxInt* pSubsets;
    };
    union
    {
        afxNat64 FrameInfluenceOffset;
        afxNat32* pFrameInfluences;
    };
};

AFX_DEFINE_STRUCT(SDKMESH_SUBSET)
{
    afxChar Name[MAX_SUBSET_NAME];
    afxNat32 MaterialID;
    afxNat32 PrimitiveType;
    afxNat64 IndexStart;
    afxNat64 IndexCount;
    afxNat64 VertexStart;
    afxNat64 VertexCount;
};

AFX_DEFINE_STRUCT(SDKMESH_FRAME)
{
    afxChar Name[MAX_FRAME_NAME];
    afxNat32 Mesh;
    afxNat32 ParentFrame;
    afxNat32 ChildFrame;
    afxNat32 SiblingFrame;
    afxM4d Matrix;
    afxNat32 AnimationDataIndex; //Used to index which set of keyframes transforms this frame
};

AFX_DEFINE_STRUCT(SDKMESH_MATERIAL)
{
    afxChar    Name[MAX_MATERIAL_NAME];

    // Use MaterialInstancePath
    afxChar    MaterialInstancePath[MAX_MATERIAL_PATH];

    // Or fall back to d3d8-type materials
    afxChar    DiffuseTexture[MAX_TEXTURE_NAME];
    afxChar    NormalTexture[MAX_TEXTURE_NAME];
    afxChar    SpecularTexture[MAX_TEXTURE_NAME];

    afxV4d Diffuse;
    afxV4d Ambient;
    afxV4d Specular;
    afxV4d Emissive;
    afxReal Power;
    
    afxNat64 Force64[6];
};

AFX_DEFINE_STRUCT(SDKMESH_MATERIAL_V2)
{
    afxChar    Name[MAX_MATERIAL_NAME];

    // PBR materials
    afxChar    RMATexture[MAX_TEXTURE_NAME];
    afxChar    AlbedoTexture[MAX_TEXTURE_NAME];
    afxChar    NormalTexture[MAX_TEXTURE_NAME];
    afxChar    EmissiveTexture[MAX_TEXTURE_NAME];

    afxReal   Alpha;

    afxChar    Reserved[60];

    afxNat64 Force64[6];
};

AFX_DEFINE_STRUCT(SDKANIMATION_FILE_HEADER)
{
    afxNat32 Version;
    afxNat8  IsBigEndian;
    afxNat32 FrameTransformType;
    afxNat32 NumFrames;
    afxNat32 NumAnimationKeys;
    afxNat32 AnimationFPS;
    afxNat64 AnimationDataSize;
    afxNat64 AnimationDataOffset;
};

AFX_DEFINE_STRUCT(SDKANIMATION_DATA)
{
    afxV3d Translation;
    afxQuat Orientation;
    afxV3d Scaling;
};

AFX_DEFINE_STRUCT(SDKANIMATION_FRAME_DATA)
{
    afxChar FrameName[MAX_FRAME_NAME];
    afxNat64 DataOffset;
};

#pragma pack(pop)

