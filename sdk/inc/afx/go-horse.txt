
// POSSÍVEIS PROBLEMAS

Uso de constante 4 ao invés de sizeof(pointer). Quando compilando em x64, tenha certeza que vai dar merda.

Quando realizando operações aritméticas sem parênteses envolvendo adição e multiplicação, o multiplicador é executado antes do adicionador, independente da ordem.

Quando usando 'for', é possível que a variável de índice operada por 'for' não esteja sendo usada em favor do valor total.

Quando houver erros a respeito da alocação de memória em si, como corrupção anômala, é provável que haja transbordo em operações de cópia sem controle de tamanho, como população de strings esperando por um valor nulo.

Evite usar union's para converter valores. O compilador pode arranjar os dados com alinhamentos diferentes.

Quando usando afxArray's (mas pode ser qualquer alocação), tipos que se auto-referenciem, tais como afxString e afxLinkage, terão suas referêncais quebradas em caso de realocação onde o buffer mude de endereço.

Quando a afxChain começa por first linkage, avança-se com obtendo o prêvio linkage.

Loop dentro de loop usando a mesma variável de controle. Exemplo: i, j, etc.
warning : declaration shadows a local variable [-Wshadow]

Float sendo convertido para int e então para float. Principalmente fatores.

Ints sendo encapsulados em ints menores. Principalmente int array para structured int16/8.

// POSSÍVEIS ABORDAGENS

NORM#1 O Qwadro não mais vai tentar evitar erros internos, apenas em entrada e saída de dados. O Qwadro apenas vai tentar informar argumentos inválidos. É responsabilidade do programador a resiliência e qualidade do código.

NORM#2 Quando uma operação é feita sob uma offset e um determinado range, deve usar tais termos. Se for operações de cópia correlativas, prefira os termos Input/Output para copy into e copy out.

NORM#3 Quando uma operação é feita sob uma source com parâmetros de precisão, tais como offset, range e stride, tais parâmetros devem ser posicionados após o parâmetro de alimentação para clareza.

Draw system poderia arranjar implementation-dependent draw contexts e dispô-los para os draw context agnósticos.

Eventos de objetos-filho deveriam ser enviados ao parente apenas.

Criar um objeto 'afxInstance*' segurando um ponteiro para um afxInstance. Referências poderiam ser movidas para o afxInstance*, talvez.
O afxInstance* seria um conector de afxInstance's tal como um binding. Venceria uma limitação de afxLinkage.

// CONVENÇÃO DE NOMENCLATURAS

Clone -> Quando um novo objeto com igual conteúdo é criado.
Copy -> Quando apenas o conteúdo é copiado entre dois objetos já existentes.
Input/Output -> Quando apenas o conteúdo é copiados com "parâmetros não-garantidos" pelo Qwadro. A exemplo, passando 'offset' e/ou 'range' especificados pelo invocador.
Fetch -> Quando há 'destreza' em uma função para conseguir algo. A exemplo, carregando um arquivo implicitamente.
Deploy -> Quando um objeto não-referenciável é empregado, isto é, inicializado, mas não é alocado.
Drop -> Quando um objeto não-referenciável é retirado, isto é, zerado, mas não é desalocado.


// TODO

Carregar arquivos ZIP como diretórios virtuais.
Carregar objetos por JSON.
Skybox
