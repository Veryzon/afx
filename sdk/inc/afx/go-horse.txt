
// POSSÍVEIS PROBLEMAS

Quando realizando operações aritméticas sem parênteses envolvendo adição e multiplicação, o multiplicador é executado antes do adicionador, independente da ordem.

Quando usando 'for', é possível que a variável de índice operada por 'for' não esteja sendo usada em favor do valor total.

Quando houver erros a respeito da alocação de memória em si, como corrupção anômala, é provável que haja transbordo em operações de cópia sem controle de tamanho, como população de strings esperando por um valor nulo.

Evite usar union's para converter valores. O compilador pode arranjar os dados com alinhamentos diferentes.

// POSSÍVEIS ABORDAGENS

NORM#1 O Qwadro não mais vai tentar evitar erros internos, apenas em entrada e saída de dados. O Qwadro apenas vai tentar informar argumentos inválidos. É responsabilidade do programador a resiliência e qualidade do código.

NORM#2 Quando uma operação é feita sob uma offset e um determinado range, deve usar tais termos. Se for operações de cópia correlativas, prefira os termos Input/Output para copy into e copy out.

NORM#3 Quando uma operação é feita sob uma source com parâmetros de precisão, tais como offset, range e stride, tais parâmetros devem ser posicionados após o parâmetro de alimentação para clareza.

Draw system poderia arranjar implementation-dependent draw contexts e dispô-los para os draw context agnósticos.

Eventos de objetos-filho deveriam ser enviados ao parente apenas.

Criar um objeto 'afxObject*' segurando um ponteiro para um afxObject. Referências poderiam ser movidas para o afxObject*, talvez.
O afxObject* seria um conector de afxObject's tal como um binding. Venceria uma limitação de afxLinkage.

// CONVENÇÃO DE NOMENCLATURAS

Clone -> Quando um novo objeto com igual conteúdo é criado.
Copy -> Quando apenas o conteúdo é copiado entre dois objetos já existentes.
Input/Output -> Quando apenas o conteúdo é copiados com "parâmetros não-garantidos" pelo Qwadro. A exemplo, passando 'offset' e/ou 'range' especificados pelo invocador.
Fetch -> Quando há 'destreza' em uma função para conseguir algo. A exemplo, carregando um arquivo implicitamente.
Deploy -> Quando um objeto não-referenciável é empregado, isto é, inicializado, mas não é alocado.
Drop -> Quando um objeto não-referenciável é retirado, isto é, zerado, mas não é desalocado.


// TODO

Carregar arquivos ZIP como diretórios virtuais.
Carregar objetos por JSON.
Skybox
