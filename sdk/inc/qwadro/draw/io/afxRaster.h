/*
 *          ::::::::  :::       :::     :::     :::::::::  :::::::::   ::::::::
 *         :+:    :+: :+:       :+:   :+: :+:   :+:    :+: :+:    :+: :+:    :+:
 *         +:+    +:+ +:+       +:+  +:+   +:+  +:+    +:+ +:+    +:+ +:+    +:+
 *         +#+    +:+ +#+  +:+  +#+ +#++:++#++: +#+    +:+ +#++:++#:  +#+    +:+
 *         +#+  # +#+ +#+ +#+#+ +#+ +#+     +#+ +#+    +#+ +#+    +#+ +#+    +#+
 *         #+#   +#+   #+#+# #+#+#  #+#     #+# #+#    #+# #+#    #+# #+#    #+#
 *          ###### ###  ###   ###   ###     ### #########  ###    ###  ########
 *
 *                  Q W A D R O   E X E C U T I O N   E C O S Y S T E M
 *
 *                                   Public Test Build
 *                       (c) 2017 SIGMA, Engineering In Technology
 *                             <https://sigmaco.org/qwadro/>
 */

// This section is part of SIGMA GL/2.

/// Textures in Qwadro are stored in as straightforward a manner as possible.
/// Each texture says what kind it is (such as color map or cube map), what encoding it is (such as raw pixels or S3TC), and how many images it has (1 for a color map, 6 for a cube map, etc.).
/// It then has a list of images, and each image lists its MIP levels.
/// That's about all there is to textures. How the texture is meant to be used (ie., as a diffuse map or a normal map or something else) is not specified in the texture itself, since it might be used differently in different materials.

#ifndef AFX_RASTER_H
#define AFX_RASTER_H

#include "qwadro/draw/afxColor.h"
#include "qwadro/io/afxUri.h"
#include "qwadro/draw/pipe/afxSampler.h"

typedef enum afxRasterFlag
{
#if !0
    afxRasterFlag_LINEAR_TILING = AfxGetBitOffset(9), /// specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).
    //afxRasterFlag_OPTIMAL = AfxGetBitOffset(10), /// specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more efficient memory access).
    //afxRasterFlag         = afxRasterFlag_LINEAR | afxRasterFlag_OPTIMAL,
#endif
    afxRasterFlag_CUBEMAP   = AfxGetBitOffset(1),

    // autogenerated by acquisition op
    afxRasterFlag_1D        = AfxGetBitOffset(2),
    afxRasterFlag_2D        = AfxGetBitOffset(3),
    afxRasterFlag_3D        = AfxGetBitOffset(4),
    afxRasterFlag_LAYERED   = AfxGetBitOffset(5), // has more than 1 layer.
    afxRasterFlag_SUBSAMPLED= AfxGetBitOffset(6), // has more than 1 LOD.
    afxRasterFlag_REVALIDATE= AfxGetBitOffset(31)
} afxRasterFlags;

typedef enum afxRasterUsage
{
    afxRasterUsage_SRC      = AfxGetBitOffset(0), /// The texture can be used as the source of a copy operation.
    afxRasterUsage_DST      = AfxGetBitOffset(1), /// The texture can be used as the destination of a copy or write operation.
    afxRasterUsage_TRANSFER = (afxRasterUsage_SRC | afxRasterUsage_DST),
    afxRasterUsage_SAMPLING = AfxGetBitOffset(2), /// The texture can be bound for use as a sampled texture in a shader.
    afxRasterUsage_STORAGE  = AfxGetBitOffset(3), /// The texture can be bound for use as a storage texture in a shader.
    afxRasterUsage_DRAW     = AfxGetBitOffset(4), /// The texture can be used as a color or depth/stencil attachment in a render pass.
    afxRasterUsage_VIDEO    = (afxRasterUsage_SAMPLING | afxRasterUsage_DRAW),

    afxRasterFlag_USAGE     = afxRasterUsage_TRANSFER | afxRasterUsage_SAMPLING | afxRasterUsage_STORAGE | afxRasterUsage_DRAW,
} afxRasterUsage;

typedef enum afxRasterAccess
{
    afxRasterAccess_R       = AfxGetBitOffset(0),
    afxRasterAccess_W       = AfxGetBitOffset(1),
    afxRasterAccess_RW      = (afxRasterAccess_R | afxRasterAccess_W),
    afxRasterAccess_X       = AfxGetBitOffset(2) /// especial caso que força a reconstrução do recurso junto ao OpenGL
} afxRasterAccess;

AFX_DEFINE_STRUCT(afxRasterRegion)
{
    afxNat                  lodIdx;
    afxNat                  baseLayer;
    afxNat                  layerCnt;
    afxWhd                  offset; /// is the initial x, y, z offsets in texels of the sub-region of the source or destination afxRaster data.
    afxWhd                  whd; /// is the size in texels of the afxRaster to copy in width, height and depth.
};

AFX_DEFINE_STRUCT(afxRasterIoOp)
/// Especificação de operação de transferência arbitrária de afxRaster.
{
    afxRasterRegion         rgn;
    afxNat                  bufOffset; /// is the offset in bytes from the start of the buffer object where the afxRaster data is copied from or to.
    afxNat                  bufRowSiz; /// (aka bytes per row) specify in texels a subregion of a larger two- or three-dimensional afxRaster in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the imageExtent.
    afxNat                  bufRowCnt; /// (aka rows per afxRaster) specify in texels a subregion of a larger two- or three-dimensional afxRaster in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the imageExtent.
};

AFX_DEFINE_STRUCT(afxRasterInfo)
{
    afxNat                  lodCnt;
    afxNat                  layerCnt;
    afxWhd                  whd;
    afxPixelFormat          fmt;
    afxNat                  sampleCnt;
    afxRasterUsage          usage;
    afxRasterFlags          flags;
};

// LOD is mip level or sample level, depending on raster

#ifdef _AFX_DRAW_C
#ifdef _AFX_RASTER_C
#ifndef _AFX_RASTER_IMPL
AFX_OBJECT(afxRaster)
#else
struct afxBaseRaster
#endif
{
    afxNat                  lodCnt; // mip level cnt
    afxNat                  layerCnt;
    afxWhd                  whd; // extent of image
    
    afxPixelFormat          fmt;
    afxNat                  sampleCnt; // 1, 2, 4, 8, 16, 32, or 64.
    afxColorSwizzling const*swizzling;
    afxByte*                maps;
    afxByte*                sidemap; // aux map (usually for indexed/palettized)
    
    afxRasterFlags          flags;
    afxRasterUsage          usage;

    afxError                (*map)(afxRaster, afxRasterRegion const *rgn, afxRasterAccess flags, afxNat *siz, afxNat* rowSiz, void**ptr);
    afxError                (*unmap)(afxRaster, afxRasterRegion const *rgn);
};
#endif
#endif//_AFX_DRAW_C

AVX afxRasterUsage  AfxGetRasterUsage(afxRaster ras);
AVX afxRasterFlags  AfxGetRasterFlags(afxRaster ras);

AVX afxNat          AfxGetRasterOffset(afxRaster ras, afxNat lodIdx, afxNat layerIdx, afxWhd const offset);
AVX void            AfxGetRasterExtent(afxRaster ras, afxNat lodIdx, afxWhd whd);

AVX afxPixelFormat  AfxGetRasterFormat(afxRaster ras);

AVX afxNat          AfxCountRasterLods(afxRaster ras);
AVX afxNat          AfxCountRasterLayers(afxRaster ras);
AVX afxNat          AfxCountRasterSamples(afxRaster ras);

AVX afxNat          AfxMeasureRasterRow(afxRaster ras, afxNat lodIdx);
AVX afxNat          AfxMeasureRasterLayer(afxRaster ras, afxNat lodIdx);
AVX afxNat          AfxMeasureRasterRegion(afxRaster ras, afxRasterRegion const *rgn);

AVX afxBool         AfxGetRasterSwizzling(afxRaster ras, afxColorSwizzling const** csw);

AVX afxRasterUsage  AfxTestRasterUsage(afxRaster ras, afxRasterUsage bitmask);
AVX afxRasterFlags  AfxTestRasterFlags(afxRaster ras, afxRasterFlags bitmask);

AVX afxError        AfxBufferizeRaster(afxRaster ras);

AVX void*           AfxOpenRasterRegion(afxRaster ras, afxRasterRegion const *rgn, afxRasterAccess flags, afxNat* rgnSiz, afxNat* rowSiz);
AVX void            AfxCloseRasterRegion(afxRaster ras, afxRasterRegion const *rgn);

// Update texture image data from arbitrary raw allocation. A safe way of copying.
AVX afxError        AfxUpdateRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], void const *src);
AVX afxError        AfxDumpRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], void *dst);

// Stream in/out texture image data from/to a stream.
AVX afxError        AfxInputRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxStream in);
AVX afxError        AfxOutputRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxStream out);

// Stream in texture image data from a file.
AVX afxError        AfxFetchRaster(afxRaster ras, afxNat lodIdx, afxNat baseLayer, afxNat layerCnt, afxUri const *uri);
AVX afxError        AfxFetchRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxUri const uri[]);

AVX afxError        AfxFetchRasterFromTarga(afxRaster ras, afxNat lodIdx, afxNat baseLayer, afxNat layerCnt, afxUri const *uri);
AVX afxError        AfxFetchRasterRegionsFromTarga(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxUri const uri[]);

// Stream out texture image data to a file.
AVX afxError        AfxPrintRaster(afxRaster ras, afxNat lodIdx, afxNat baseLayer, afxNat layerCnt, afxUri const *uri);
AVX afxError        AfxPrintRasterRegions(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxUri const uri[]);

AVX afxError        AfxPrintRasterToTarga(afxRaster ras, afxNat lodIdx, afxNat baseLayer, afxNat layerCnt, afxUri const *uri);
AVX afxError        AfxPrintRasterRegionsToTarga(afxRaster ras, afxNat opCnt, afxRasterIoOp const ops[], afxUri const uri[]);

////////////////////////////////////////////////////////////////////////////////

AVX afxError        AfxAcquireRasters(afxDrawContext dctx, afxNat cnt, afxRasterInfo const info[], afxRaster rasters[]);

AVX afxError        AfxLoadRastersFromTarga(afxDrawContext dctx, afxRasterUsage usage, afxRasterFlags flags, afxNat cnt, afxUri const uri[], afxRaster rasters[]);

AVX afxRaster       AfxAssembleRaster(afxDrawContext dctx, afxRasterUsage usage, afxRasterFlags flags, afxNat cnt, afxUri const uri[]);
AVX afxError        AfxAssembleRastersFromTarga(afxDrawContext dctx, afxRasterUsage usage, afxRasterFlags flags, afxNat cnt, afxUri const uri[], afxRaster* ras);
AVX afxRaster       AfxAssembleCubemapRasters(afxDrawContext dctx, afxRasterUsage usage, afxRasterFlags flags, afxUri const uri[6]);

#endif//AFX_RASTER_H
